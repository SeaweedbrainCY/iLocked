//
//  ImportKeys.swift
//  iLocked
//
//  Created by Stchepinsky Nathan on 31/07/2021.
//  Copyright Â© 2021 Nathan. All rights reserved.
//

import Foundation
import UIKit
import MobileCoreServices
import UniformTypeIdentifiers

class ImportKeys:UIViewController, UITextViewDelegate, UIDocumentPickerDelegate
 {
    
    @IBOutlet weak var importButton: UIButton!
    @IBOutlet weak var textToImport : UITextView!
    @IBOutlet weak var txtFileButton: UIButton!
    @IBOutlet weak var activityIndicator: UIActivityIndicatorView!
    @IBOutlet weak var checkMark: UIImageView!
    
    let placeHolder = "Paste your keys export text"
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.textToImport.delegate = self
        self.activityIndicator.layer.cornerRadius = 10
    }
    
    func textViewDidBeginEditing(_ textView: UITextView) {
        if textView.text == placeHolder{
            textView.text = ""
            textView.textColor = UIColor.white
        }
    }

    func alert(_ title: String, message: String, quitMessage: String) {
        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)
        let ok = UIAlertAction(title: quitMessage, style: UIAlertAction.Style.cancel, handler: nil)
        alert.addAction(ok)
        self.present(alert, animated: true, completion: nil)
    }
    
    func textViewDidEndEditing(_ textView: UITextView){
        if textView.text == "" {
            textView.text = placeHolder
            textView.textColor = .darkGray
        }
    }
    
    //
    // IBAction func
    //
    
    @IBAction func importTxtSelected(sender: UIButton) {
        let picker = UIDocumentPickerViewController.init(documentTypes: [String(kUTTypeText)], in: .open)
        picker.delegate = self
        picker.modalPresentationStyle = .fullScreen
        self.present(picker, animated: true, completion: {
            self.activityIndicator.startAnimating()
        })
    }
    
    @IBAction func importKeysSelected(sender: UIButton){
        if textToImport.text == "" || textToImport.text == self.placeHolder {
            alert("Paste your keys export text to import keys", message: "Paste the text generated by iLocked while exporting your keys. iLocked supports human readable and JSON formats.", quitMessage: "Ok")
        }
    }
    
    //
    // Delegate func
    //
    
    public func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]){
        guard let myURL = urls.first else {
            impossibleToRetrieveTxt()
            return
        }
        print("import result : \(myURL.relativePath)")
        do {
            let contents = try String(contentsOfFile: myURL.relativePath, encoding: .utf8)
                
            let myStrings = contents.components(separatedBy: .newlines)
                    let text = myStrings.joined(separator: "\n")
            print(text)
            extractFromTxt(text)
                } catch {
                    print(error)
                    impossibleToRetrieveTxt()
                }
    }
    
    //
    // Keys dealing func (.txt)
    //
    
    func extractFromTxt(_ text:String){
        let public_start = keyFormat.pem_public.start
        let public_end = keyFormat.pem_public.end
        let private_start = keyFormat.pem_private.start
        let private_end = keyFormat.pem_private.end
        
        
        var publicKey :String? = nil
        var privateKey : String? = nil
        
        
        // extract public key
        let splited_public_start = text.components(separatedBy: public_start)
        if splited_public_start.count == 2 {
            if splited_public_start[0].contains(public_end){
                let splited_public_end = splited_public_start[0].components(separatedBy: public_end)
                if splited_public_end.count == 2 {
                    publicKey = splited_public_end[0]
                } else {
                    impossibleToExtractKeys()
                }
            } else if splited_public_start[1].contains(public_end) {
                let splited_public_end = splited_public_start[1].components(separatedBy: public_end)
                if splited_public_end.count == 2 {
                    publicKey = splited_public_end[0]
                } else {
                    impossibleToExtractKeys()
                }
            } else {
                impossibleToExtractKeys()
            }
        } else {
            impossibleToExtractKeys()
        }
        
        // extract private key
        let splited_private_start = text.components(separatedBy: private_start)
        if splited_private_start.count == 2 {
            if splited_private_start[0].contains(private_end){
                let splited_private_end = splited_private_start[0].components(separatedBy: private_end)
                if splited_private_end.count == 2 {
                    publicKey = splited_private_end[0]
                } else {
                    impossibleToExtractKeys()
                }
            } else if splited_private_start[1].contains(private_end) {
                let splited_private_end = splited_private_start[1].components(separatedBy: private_end)
                if splited_private_end.count == 2 {
                    privateKey = splited_private_end[0]
                } else {
                    impossibleToExtractKeys()
                }
            } else {
                impossibleToExtractKeys()
            }
        } else {
            impossibleToExtractKeys()
        }
        
        if publicKey != nil && privateKey != nil {
            print("Success to extract keys")
            publicKey = KeyId().key_format(publicKey!)
            saveKeys(publicKey: publicKey!, privateKey: privateKey!)
        } else {
            impossibleToExtractKeys()
        }
        
    }
    
    func saveKeys(publicKey:String, privateKey: String){
        let saveSuccessfulPrivateKey = KeychainWrapper.standard.set(privateKey, forKey: UserKeys.privateKey.tag)
        let saveSuccessfulPublicKey = KeychainWrapper.standard.set(publicKey, forKey: UserKeys.publicKey.tag)
        if !saveSuccessfulPrivateKey && !saveSuccessfulPublicKey {
            self.activityIndicator.stopAnimating()
            alert("Impossible to save your keys", message: "Please check you have enough place in your iDevice.", quitMessage: "Ok")
        } else { // success
            self.activityIndicator.stopAnimating()
            let settingData = SettingsData()
            var settingDict = settingData.getSetting()
            var isX509 = false
            if let publicKeyData = Data(base64Encoded: publicKey) {
                do {
                    isX509 = try publicKeyData.hasX509Header()
                } catch {
                    print("Impossible to verify X509 certificate")
                    isX509 = false
                }
                
            }
                settingDict.updateValue(String(isX509), forKey: SettingsName.X509Certificate.key)
            settingData.saveSetting(dict: settingDict)
            let animation = UIViewPropertyAnimator(duration: 0.8, curve: .linear, animations: {
                self.checkMark.alpha = 1
            })
            animation.startAnimation()
            self.perform(#selector(performSegueWithDelay), with: nil, afterDelay: 1)
        }
        
    }
    
    //
    // Keys dealing func (human readable or JSON)
    //
    
    func extractKeysFromString(_ str:String){
        var isPEM = false
        var privateKey:String?
        var publicKey:String?
        let dictIfJSON = str.toJSON() // if == [""] then it's not in JSON format
        if dictIfJSON != [""]{ // it's JSON
            /*if let type = dictIfJSON[ExportKeysJSON.type.key]{
                if type != "RSA-4096"{
                    incorrectInfo()
                }
            }*/
            if let format = dictIfJSON[ExportKeysJSON.format]
        }
    }
    
    //
    // Obj C func
    //
    
    @objc func performSegueWithDelay(){
        performSegue(withIdentifier: "homePage", sender: self)
    }
    
    //
    // Error alert func
    //
    
    func impossibleToRetrieveTxt(){
        self.activityIndicator.stopAnimating()
        alert("Impossible to retrieve your .txt", message: "Your .txt file seems to be unreachable. Please try again", quitMessage: "Ok")
    }
    
    func impossibleToExtractKeys(){
        self.activityIndicator.stopAnimating()
        alert("Impossible to extract your .txt", message: "Your keys can't be extracted from your text file. Please, only try to import a text file generated by iLocked.", quitMessage: "Ok")
    }
    
    func incorrectInfo(){
        self.activityIndicator.stopAnimating()
        alert("Impossible to retrieve your keys", message: "Your keys can't be extracted because informations provided are incorrect or corrupted. Please, only try to import a text file generated by iLocked.", quitMessage: "Ok")
    }
    
}
